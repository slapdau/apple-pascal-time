        .macro  POP
        pla
        sta     %1
        pla
        sta     %1+1
        .endm

        .macro  PUSH
        lda     %1+1
        pha
        lda     %1
        pha
        .endm

        .macro  RMVBIAS
        pla
        pla
        pla
        pla
        .endm

; daterec = packed record
;     month: 0..12;
;     day  : 0..31;
;     year : 0..100
; end {daterec};
; timerec = packed record
;     hour   : 0..23;
;     minute : 0..59;
;     filler1: 0..31;
;     second : 0..59;
;     filler2: 0..2047
; end {timerec};
; clockrec = record
;     date: daterec;
;     time: timerec
; end {clockrec};

; function InitClock:boolean;

; procedure ReadClock(var now:clockrec);
; external;

STATEREG .equ   0C068
ROMBNK2 .equ    0C08A
LCBANK2 .equ    0C083
LCBANK1 .equ    0C08B
RDLCBNK .equ    0C011
RDLCRAM .equ    0C012

PTIME   .equ    0.
RETURN  .equ    2.
WKSPACE .equ    4.
MEMSTS  .equ    10.

        .func InitClock,0
        .ref CLKVECT,RDVECT
        
        pop     RETURN
        rmvbias
        
        jsr     TestClk
        bcs     NoClk
        
        lda     CLKVECT
        sta     RDVECT
        lda     CLKVECT+1
        sta     RDVECT+1
        lda     #0
        pha
        lda     #1
        pha
        bcc     ExitInit

NoClk   lda     #0
        pha
        lda     #0
        pha

ExitInit
        push    RETURN
        rts

        ; Implement the test in Appendix B of the Apple IIgs Firmware
        ; Reference Manual.
        ; Note: This routine does not use the memory state register
        ; at $C068. The whole point of this routine is that we don't
        ; know yet if we're running in a IIgs.
TestClk
        ; Save memory status and set read from ROM.
        rol     RDLCBNK
        rol     MEMSTS
        rol     RDLCRAM
        rol     MEMSTS
        lda     ROMBNK2
        
        ; Test the system ID bytes.
        lda     0FBB3
        cmp     #006
        bne     ClkBad
        lda     0FBC0
        cmp     #0E0
        bne     ClkBad
        lda     0FBBF
        cmp     #00
        bne     ClkBad
        
        ; Call the IIgs ID routine.
        ; An enhanced //e will leave the carry set.
        ; A IIgs will clear the carry and leave hardware status in the
        ; accumulator.
        sec
        jsr     0FE1F
        bcs     ClkBad
        and     #010            ; Test the built-in clock bit.
        bne     ClkGood
        
ClkBad  sec
ClkGood php

        ; Restore memory status. This is probably overkill. Should be safe
        ; to just assume R/W Language Card Bank 1.
        ror     MEMSTS
        bcc     $9
        ror     MEMSTS
        bcc     $1
        lda     LCBANK2
        lda     LCBANK2
        bcs     $9
$1      lda     LCBANK1
        lda     LCBANK1
$9      plp
        rts
        
        .proc   ReadClock,1
        
        pop     RETURN
        pop     PTIME
        
        jsr RdIfClk
        
        ldy     #5
$1      lda     WKSPACE,y
        sta     @PTIME,y
        dey
        bpl     $1

        push    RETURN
        rts

RdIfClk
        .def CLKVECT,RDVECT
        jmp     @RDVECT
RDVECT  .word   ClrWkSpc
CLKVECT .word   RdPasTime

ClrWkSpc
        ; Zero out workspace for return.
        lda     #0
        ldy     #5
$1      sta     WKSPACE,y
        dey
        bpl     $1
        
        rts
        
RdPasTime
        jsr     RdHexTime
        
        ; Seconds
        pla
        sta     WKSPACE+4
        lda     #0
        sta     WKSPACE+5
        sta     WKSPACE+2
        
        ; Minutes
        clc
        pla
        ror     A
        ror     WKSPACE+2
        ror     A
        ror     WKSPACE+2
        ror     A
        ror     WKSPACE+2
        sta     WKSPACE+3
        
        ; Hour
        pla
        ora     WKSPACE+2
        sta     WKSPACE+2
        
        ; Year
        pla
$1      cmp     #100.
        bcc     $2
        sbc     #100.
        bcs     $1
$2      sta     WKSPACE+1
        
        ; Day
        pla
        clc
        adc     #1
        asl     A
        asl     A
        asl     A
        rol     A
        rol     WKSPACE+1
        sta     WKSPACE
        
        ; Month
        pla
        clc
        adc     #1
        ora     WKSPACE
        sta     WKSPACE
        
        ; Clear null byte and day of week from stack.
        pla
        pla
        
        rts
        
RdHexTime
        pop     $1
        
        lda     STATEREG
        sta     $3
        and     #0CF
        sta     STATEREG
        
        php
        sei             ; Disable interupts. Doubt Pascal interrupt
        pla             ; handlers could cope.
        sta     $2
        
        ; The following code blob is position independant 65816 code
        ; that calls ReadTimeHex in the IIgs Miscelaneous Tool Set.
        ; It's assembled externally.

        .byte   018             ; clc
        .byte   0FB             ; xce
        .byte   0C2,030         ; rep #$30
        .byte   0A9,000,000     ; lda #$0000
        .byte   048             ; pha
        .byte   048             ; pha
        .byte   048             ; pha
        .byte   048             ; pha
        .byte   0A2,003,00D     ; ldx #$0D03
        .byte   022,000,000,0E1 ; jsl $e10000
        .byte   038             ; sec
        .byte   0FB             ; xce
        
        ; After the return to the caller, the stack will look like:
        ; | Prev. Content|
        ; | weekday      | 1-7, with 1=Sunday
        ; | 0            |
        ; | month        | 0-11, with 0=January
        ; | day          | 0-30
        ; | curYear      | Current year minus 1900
        ; | hour         | 0-23
        ; | minute       | 0-59
        ; | second       | 0-59
        ; |--------------| <-- SP
        
        lda     $2
        pha
        plp
        
        lda     $3
        sta     STATEREG
        
        push    $1
        rts

$1      .word   0
$2      .byte   0
$3      .byte   0

                ; 21:24:45, 12-Jan-18
; TIMEVAL .word   024c1, 00315, 0002d
        
        .end

